<!DOCTYPE html>
<html>
  <head>
    <link rel="stylesheet" href="styles.css" />
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs/dist/tf.min.js"></script>
    <!-- Require the peer dependencies of pose-detection. -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter"></script>

    <!-- You must explicitly require a TF.js backend if you're not using the TF.js union bundle. -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl"></script>

    <!-- Load three.js -->
    <!-- <script src="https://cdn.jsdelivr.net/npm/three@0.106.2/build/three.min.js"></script> -->
    <!-- Load scatter-gl.js -->
    <!-- <script src="https://cdn.jsdelivr.net/npm/scatter-gl@0.0.1/lib/scatter-gl.min.js"></script> -->

    <script src="https://cdn.jsdelivr.net/npm/three@0.125/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/scatter-gl@0.0.11/lib/scatter-gl.min.js"></script>

    <script>
      // These points will be added to scale the plot, but will be painted white to hide
      const ANCHOR_POINTS = [
        [0, 0, 0],
        [0, 1, 0],
        [-1, 0, 0],
        [-1, -1, 0],
      ]
      function spinEm() {
        // window.inputContainer.resize()
        window.inputContainer.startOrbitAnimation &&
          window.inputContainer.startOrbitAnimation()
        window.goalContainer.startOrbitAnimation &&
          window.goalContainer.startOrbitAnimation()
        window.transformedContainer.startOrbitAnimation &&
          window.transformedContainer.startOrbitAnimation()
        window.rotateContainer.startOrbitAnimation &&
          window.rotateContainer.startOrbitAnimation()
      }
      function selectColor(colorNum, totalPoints, colors) {
        if (colors < 1) colors = 1 // avoid divide by zero
        if (colorNum >= totalPoints) return 'white'
        if (colorNum >= colors) return 'black'
        return 'hsl(' + ((colorNum * (360 / colors)) % 360) + ',100%,50%)'
      }

      function simpleTriangle(delta = [1, 1, 1]) {
        const polyPoints = [
          [-0.5, -0.5, -0.5],
          [0.5, 0.5, 0.5],
          [1, 0, 1],
        ]
        polyPoints.forEach((point, i) => {
          polyPoints[i][0] *= delta[0]
          polyPoints[i][1] *= delta[1]
          polyPoints[i][2] *= delta[2]
        })

        const metadata = [
          {
            labelIndex: 0,
            label: polyPoints[0],
          },
          {
            labelIndex: 1,
            label: polyPoints[1],
          },
          {
            labelIndex: 2,
            label: polyPoints[2],
          },
        ]
        const sequences = [
          {
            indices: [0, 1],
          },
          {
            indices: [0, 2],
            indices: [1, 2],
          },
          {
            indices: [1, 2],
            indices: [2, 0],
          },
        ]
        return {
          metadata,
          sequences,
          polyPoints,
        }
      }

      function generateMeta(polyPoints) {
        const metadata = []
        const sequences = []
        for (let i = 0; i < polyPoints.length; i++) {
          // Add point labels
          metadata.push({
            labelIndex: i,
            label: `X: ${Number(polyPoints[i][0]).toFixed(1)} Y: ${Number(
              polyPoints[i][1]
            ).toFixed(1)} Z: ${Number(polyPoints[i][2]).toFixed(1)}`,
          })

          // Draw a line
          sequences.push({ indices: [i, (i + 1) % polyPoints.length] })
        }
        return { metadata, sequences }
      }

      function create3DPolygon(points = 3) {
        // Create *points* number of points 3D space (X, Y, Z)
        const polyPoints = Array.from({ length: points }, () => [
          Math.random(),
          Math.random(),
          Math.random(),
        ])

        const { metadata, sequences } = generateMeta(polyPoints)
        return {
          metadata,
          sequences,
          polyPoints,
        }
      }

      function drawMulti(destination, polies) {
        // Create scatter graph
        const containerElement = document.getElementById(destination)
        // if it exists grab the existing one
        const scatterGL = window[destination].sequences
          ? window[destination]
          : new ScatterGL(containerElement)

        let pointSize = 0
        let totalSequence = []
        let dataset = []
        let pointsMeta = []
        polies.forEach((polygon) => {
          const { polyPoints, sequences } = polygon
          const { metadata } = generateMeta(polyPoints) // Regenerate meta for changes
          dataset = [...dataset, ...polyPoints]
          const bumpedSequences = sequences.map((sequence) => {
            const bumped = sequence.indices.map((index) => index + pointSize)
            return { indices: bumped }
          })
          const metaMiddle = metadata.map((meta, i) => ({
            labelIndex: pointSize,
            label: meta.label,
          }))
          pointSize += polyPoints.length
          pointsMeta = [...pointsMeta, ...metaMiddle]
          totalSequence = [...totalSequence, ...bumpedSequences]
        })

        glDataset = new ScatterGL.Dataset(
          [...dataset, ...ANCHOR_POINTS],
          pointsMeta
        )

        // Add data to scatter graph + lines
        if (window[destination].sequences) {
          scatterGL.updateDataset(glDataset, totalSequence)
        } else {
          scatterGL.render(glDataset)
          scatterGL.setSequences(totalSequence)
        }
        scatterGL.setPointColorer((index) =>
          selectColor(index, pointSize, polies[0].polyPoints.length)
        )
        scatterGL.scatterPlot.setPolylineOpacities(new Array(pointSize).fill(1))

        // store on Global for debug accessibility
        window[destination] = scatterGL
        console.log({ destination, pointSize, totalSequence, dataset })
      }

      function createR() {
        const random = simpleTriangle([1, 1, 0.2])
        const triangle = simpleTriangle()
        drawMulti('rotateContainer', [random, triangle])
        // store R in global for debug accessibility
        window.R = [random, triangle]
      }

      function originPoly(polyIndex = 0) {
        const R = window.R
        const polygon = R[polyIndex]
        const focalPoint = polygon.polyPoints[0]
        polygon.polyPoints.map((point, idx) => {
          polygon.polyPoints[idx] = point.map((v, i) => v - focalPoint[i])
        })
        R[polyIndex] = polygon
        drawMulti('rotateContainer', R)
        window.R = R
      }

      function alignPoly(polyIndex = 0) {
        const R = window.R
        let polygon = R[polyIndex]
        let alignPoint = polygon.polyPoints[1]

        const xang = Math.atan2(alignPoint[1], alignPoint[0])
        polygon = rotate('z', polyIndex, xang)

        alignPoint = polygon.polyPoints[1]
        const zang = Math.atan2(alignPoint[2], alignPoint[0])
        rotate('y', polyIndex, zang)
      }

      function rotateToGoal() {
        const R = window.R
        const rotatePoint = R[0].polyPoints[2]
        const goalRotatePoint = R[1].polyPoints[2]

        const myang = Math.atan2(rotatePoint[2], rotatePoint[1])
        const byang = Math.atan2(goalRotatePoint[2], goalRotatePoint[1])
        const yang = byang - myang
        rotate('x', 0, yang)
      }

      function rotate(axis, polyIndex = 0, rads = 0.1) {
        const R = window.R
        const polygon = R[polyIndex]
        const theta = tf.scalar(rads)
        const tc = theta.cos().arraySync()
        const ts = theta.sin().arraySync()
        // https://en.wikipedia.org/wiki/Rotation_matrix#Basic_rotations
        // https://robotics.stackexchange.com/questions/10702/rotation-matrix-sign-convention-confusion
        let rotateMatrix // Not the normal right-hand rule version
        if (axis === 'x') {
          rotateMatrix = tf.tensor([
            [1, 0, 0],
            [0, tc, -ts],
            [0, ts, tc],
          ])
        } else if (axis === 'y') {
          rotateMatrix = tf.tensor([
            [tc, 0, ts],
            [0, 1, 0],
            [-ts, 0, tc],
          ])
        } else if (axis === 'z') {
          rotateMatrix = tf.tensor([
            [tc, ts, 0],
            [-ts, tc, 0],
            [0, 0, 1],
          ])
        }

        // Debugging math
        const x = polygon.polyPoints[1][0]
        const y = polygon.polyPoints[1][1]
        const newX = tf.add(tf.mul(theta.cos(), x), tf.mul(theta.sin(), y))
        const newY = tf.sub(tf.mul(theta.sin(), x), tf.mul(theta.cos(), y))
        const solvedX = newX.arraySync()
        const solvedY = newY.arraySync()
        console.log({ solvedX, solvedY })

        polygon.polyPoints.map((alignPoint, alignPointIndex) => {
          const tensorAlign = tf.tensor(alignPoint).reshape([3, 1])
          const newAlignPoint = tf.matMul(rotateMatrix, tensorAlign)
          const movedPoint = newAlignPoint.arraySync()
          polygon.polyPoints[alignPointIndex] = movedPoint
        })

        R[polyIndex] = polygon
        drawMulti('rotateContainer', R)

        window.R = R
        return polygon
      }

      async function runCode() {
        const inputPolygon = create3DPolygon(3)
        drawMulti('inputContainer', [inputPolygon])
        const goalPolygon = create3DPolygon(3)
        drawMulti('goalContainer', [goalPolygon])

        // Step 1:  Re-origin on focal point
        const fixPointIndex = 0
        const focalPoint = goalPolygon.polyPoints[fixPointIndex]
        const transformVector = focalPoint.map(
          (v, i) => v - inputPolygon.polyPoints[fixPointIndex][i]
        )
        const polyPoints = inputPolygon.polyPoints.map((point) => {
          return point.map((coord, i) => coord + transformVector[i])
        })

        // Step 2: 2D Rotate around focal point to align with alignPoint
        const alignPointIndex = 1
        const alignPoint = goalPolygon.polyPoints[alignPointIndex]
        const rotationPoint = polyPoints[alignPointIndex]
        // Calculate vector angle using (u*v)/|u||v|
        const dotprod = tf.dot(focalPoint, alignPoint)
        const magnitude1 = tf.norm(alignPoint)
        const magnitude2 = tf.norm(focalPoint)
        const theta = tf.acos(dotprod.div(magnitude1.mul(magnitude2)))
        // Create rotation matrix with theta
        const tc = theta.cos().arraySync()
        const ts = theta.sin().arraySync()
        // https://en.wikipedia.org/wiki/Rotation_matrix#Basic_rotations
        const rx = tf.tensor([
          [1, 0, 0],
          [0, tc, -ts],
          [0, ts, tc],
        ])
        const tensorAlign = tf.tensor(alignPoint).reshape([3, 1])
        const newAlignPoint = tf.matMul(rx, tensorAlign)
        const movedPoint = newAlignPoint.arraySync()
        polyPoints[alignPointIndex] = movedPoint

        // Step 3: Draw transformed polygon
        const { metadata, sequences } = generateMeta(polyPoints)
        const transformedPolygon = {
          metadata,
          sequences,
          polyPoints,
        }
        drawMulti('transformedContainer', [transformedPolygon])
      }
    </script>
  </head>
  <body>
    <h1>3D Polygon Normalization</h1>

    <h2>Concept Training</h2>
    <div>
      <div class="grouping">
        <div id="rotateContainer" class="chart"></div>
      </div>
      <div class="stepControls">
        <div class="creators">
          <button onclick="createR()">Create Triangles</button>
          <button onclick="createT()">Create Tetrahedrons</button>
        </div>
        <div>
          <button onclick="originPoly(1)">Move Goal to Origin</button>
          <button onclick="originPoly(0)">Move Input to Origin</button>
          <button onclick="alignPoly(1)">Align Goal Secondary</button>
          <button onclick="alignPoly(0)">Align Input Secondary</button>
          <button onclick="rotateToGoal()">Rotate Input to Goal</button>
        </div>
      </div>
    </div>
    <div class="funland">
      <button onclick="rotate('x')">Rotate X</button>
      <button onclick="rotate('y')">Rotate Y</button>
      <button onclick="rotate('z')">Rotate Z</button>
    </div>
    <hr />
    <div id="squeezer">
      <div class="poseGroup">
        <div class="grouping">
          <h2>Input</h2>
          <div id="inputContainer" class="chart"></div>
        </div>
        <div class="grouping">
          <h2>Goal</h2>
          <div id="goalContainer" class="chart"></div>
        </div>
        <div class="grouping">
          <h2>Transformed</h2>
          <div id="transformedContainer" class="chart"></div>
        </div>
      </div>
    </div>

    <div id="controls">
      <button onclick="runCode()">Process stuff</button>
      <button onclick="spinEm()">Spin Em</button>
    </div>
  </body>
</html>
