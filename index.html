<!DOCTYPE html>
<html>
  <head>
    <link rel="stylesheet" href="styles.css" />
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs/dist/tf.min.js"></script>
    <!-- Require the peer dependencies of pose-detection. -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter"></script>

    <!-- You must explicitly require a TF.js backend if you're not using the TF.js union bundle. -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl"></script>

    <!-- Load three.js -->
    <!-- <script src="https://cdn.jsdelivr.net/npm/three@0.106.2/build/three.min.js"></script> -->
    <!-- Load scatter-gl.js -->
    <!-- <script src="https://cdn.jsdelivr.net/npm/scatter-gl@0.0.1/lib/scatter-gl.min.js"></script> -->

    <script src="https://cdn.jsdelivr.net/npm/three@0.125/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/scatter-gl@0.0.11/lib/scatter-gl.min.js"></script>

    <script>
      // These points will be added to scale the plot, but will be painted white to hide
      const ANCHOR_POINTS = [
        [0, 0, 0],
        [0, 1, 0],
        [-1, 0, 0],
        [-1, -1, 0],
      ]
      function spinEm() {
        // window.inputContainer.resize()
        window.inputContainer && window.inputContainer.startOrbitAnimation()
        window.goalContainer && window.goalContainer.startOrbitAnimation()
        window.transformedContainer &&
          window.transformedContainer.startOrbitAnimation()
      }
      function selectColor(colorNum, colors) {
        if (colors < 1) colors = 1 // defaults to one color - avoid divide by zero
        if (colorNum >= colors) return 'white'
        return 'hsl(' + ((colorNum * (360 / colors)) % 360) + ',100%,50%)'
      }

      function generateMeta(polyPoints) {
        const metadata = []
        const sequences = []
        for (let i = 0; i < polyPoints.length; i++) {
          // Add point labels
          metadata.push({
            labelIndex: i,
            label: `X: ${Number(polyPoints[i][0]).toFixed(1)} Y: ${Number(
              polyPoints[i][1]
            ).toFixed(1)} Z: ${Number(polyPoints[i][2]).toFixed(1)}`,
          })

          // Draw a line
          sequences.push({ indices: [i, (i + 1) % polyPoints.length] })
        }
        return { metadata, sequences }
      }

      function create3DPolygon(points = 3) {
        // Create *points* number of points 3D space (X, Y, Z)
        const polyPoints = Array.from({ length: points }, () => [
          Math.random(),
          Math.random(),
          Math.random(),
        ])

        const { metadata, sequences } = generateMeta(polyPoints)
        return {
          metadata,
          sequences,
          polyPoints,
        }
      }

      function drawPolygon(destination, polygon) {
        // Create scatter graph
        const containerElement = document.getElementById(destination)
        // if it exists grab the existing one
        const scatterGL = window[destination].sequences
          ? window[destination]
          : new ScatterGL(containerElement)

        // Get polydata
        const { polyPoints, metadata, sequences } = polygon
        const dataset = new ScatterGL.Dataset(
          [...polyPoints, ...ANCHOR_POINTS],
          metadata
        )

        // Add data to scatter graph + lines
        if (window[destination].sequences) {
          scatterGL.updateDataset(dataset, sequences)
        } else {
          scatterGL.render(dataset)
          scatterGL.setSequences(sequences)
        }
        scatterGL.setPointColorer((index) =>
          selectColor(index, polyPoints.length)
        )
        scatterGL.scatterPlot.setPolylineOpacities(
          new Array(polyPoints.length).fill(1)
        )

        // store on Global for debug accessibility
        window[destination] = scatterGL
      }

      function createR() {
        const R = create3DPolygon(3)
        drawPolygon('rotateContainer', R)
      }

      async function runCode() {
        const inputPolygon = create3DPolygon(3)
        drawPolygon('inputContainer', inputPolygon)
        const goalPolygon = create3DPolygon(3)
        drawPolygon('goalContainer', goalPolygon)

        // Step 1:  Re-origin on focal point
        const fixPointIndex = 0
        const focalPoint = goalPolygon.polyPoints[fixPointIndex]
        const transformVector = focalPoint.map(
          (v, i) => v - inputPolygon.polyPoints[fixPointIndex][i]
        )
        const polyPoints = inputPolygon.polyPoints.map((point) => {
          return point.map((coord, i) => coord + transformVector[i])
        })

        // Step 2: 2D Rotate around focal point to align with alignPoint
        const alignPointIndex = 1
        const alignPoint = goalPolygon.polyPoints[alignPointIndex]
        const rotationPoint = polyPoints[alignPointIndex]
        // Calculate vector angle using (u*v)/|u||v|
        const dotprod = tf.dot(focalPoint, alignPoint)
        const magnitude1 = tf.norm(alignPoint)
        const magnitude2 = tf.norm(focalPoint)
        const theta = tf.acos(dotprod.div(magnitude1.mul(magnitude2)))
        // Create rotation matrix with theta
        const tc = theta.cos().arraySync()
        const ts = theta.sin().arraySync()
        // https://en.wikipedia.org/wiki/Rotation_matrix#Basic_rotations
        const rx = tf.tensor([
          [1, 0, 0],
          [0, tc, -ts],
          [0, ts, tc],
        ])
        const tensorAlign = tf.tensor(alignPoint).reshape([3, 1])
        const newAlignPoint = tf.matMul(rx, tensorAlign)
        const movedPoint = newAlignPoint.arraySync()
        polyPoints[alignPointIndex] = movedPoint

        // Step 3: Draw transformed polygon
        const { metadata, sequences } = generateMeta(polyPoints)
        const transformedPolygon = {
          metadata,
          sequences,
          polyPoints,
        }
        drawPolygon('transformedContainer', transformedPolygon)
        console.log({
          inputPolygon,
          goalPolygon,
          transformedPolygon,
        })
      }
    </script>
  </head>
  <body>
    <h1>3D Polygon Normalization</h1>
    <div id="squeezer">
      <div class="poseGroup">
        <div class="grouping">
          <h2>Input</h2>
          <div id="inputContainer" class="chart"></div>
        </div>
        <div class="grouping">
          <h2>Goal</h2>
          <div id="goalContainer" class="chart"></div>
        </div>
        <div class="grouping">
          <h2>Transformed</h2>
          <div id="transformedContainer" class="chart"></div>
        </div>
      </div>
    </div>

    <div id="controls">
      <button onclick="runCode()">Process stuff</button>
      <button onclick="spinEm()">Spin Em</button>
    </div>

    <hr />
    <h2>Concept Training</h2>
    <div>
      <div class="grouping">
        <div id="rotateContainer" class="chart"></div>
      </div>
      <button onclick="createR()">Create</button>
      <button onclick="rotateLeft()">Rotate Left</button>
      <button onclick="rotateRight()">Rotate Right</button>
    </div>
  </body>
</html>
